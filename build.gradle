/*
 * Bearsampp Module Memcached - Pure Gradle Build
 *
 * This build configuration handles downloading, extracting, and packaging Memcached releases.
 *
 * VERSION RESOLUTION STRATEGY (3-tier fallback):
 *   1. Local releases.properties (primary source)
 *   2. Remote modules-untouched memcached.properties (automatic fallback)
 *      URL: https://github.com/Bearsampp/modules-untouched/blob/main/modules/memcached.properties
 *   3. Standard URL format construction (last resort)
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=1.6.39     - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 */

plugins {
    id 'base'
}

// ============================================================================
// PROJECT CONFIGURATION
// ============================================================================

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Load releases properties
def releasesProps = new Properties()
file('releases.properties').withInputStream { releasesProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'memcached')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'memcached')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // Build paths
    def buildPathFromProps = buildProps.getProperty('build.path', '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"

    buildBasePath = buildPathFromProps ?: (buildPathFromEnv ?: defaultBuildPath)
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath
}

// Configure repositories
repositories {
    mavenCentral()
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Get available versions from bin and bin/archived directories
def getAvailableVersions() {
    def versions = []

    // Check bin directory
    def binDir = file("${projectDir}/bin")
    if (binDir.exists()) {
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            .each { versions.add(it.name.replace(bundleName, '')) }
    }

    // Check bin/archived directory
    def archivedDir = file("${projectDir}/bin/archived")
    if (archivedDir.exists()) {
        archivedDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .each { versions.add(it.name.replace(bundleName, '')) }
    }

    // Sort versions
    return versions.sort { a, b ->
        def aParts = a.tokenize('.')
        def bParts = b.tokenize('.')
        for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
            def aNum = aParts[i].toInteger()
            def bNum = bParts[i].toInteger()
            if (aNum != bNum) return aNum <=> bNum
        }
        return aParts.size() <=> bParts.size()
    }
}

// Get the path for a specific version (checks bin and bin/archived)
def getVersionPath(String version) {
    def binPath = file("${projectDir}/bin/${bundleName}${version}")
    if (binPath.exists()) {
        return binPath
    }

    def archivedPath = file("${projectDir}/bin/archived/${bundleName}${version}")
    if (archivedPath.exists()) {
        return archivedPath
    }

    return null
}

// Get the location tag for a version
def getVersionLocation(String version) {
    def binPath = file("${projectDir}/bin/${bundleName}${version}")
    if (binPath.exists()) {
        return "[bin]"
    }

    def archivedPath = file("${projectDir}/bin/archived/${bundleName}${version}")
    if (archivedPath.exists()) {
        return "[bin/archived]"
    }

    return "[unknown]"
}

// Check if version exists in releases.properties
def versionExistsInReleases(String version) {
    return releasesProps.getProperty(version) != null
}

// Fetch memcached.properties from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/memcached.properties"

    println "Fetching memcached.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"

    def tempFile = file("${bundleTmpDownloadPath}/memcached-untouched.properties")
    tempFile.parentFile.mkdirs()

    try {
        ant.get(src: propsUrl, dest: tempFile, verbose: false, ignoreerrors: false)

        def props = new Properties()
        tempFile.withInputStream { props.load(it) }

        println "  Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  Warning: Could not fetch memcached.properties from modules-untouched: ${e.message}"
        println "  Will fall back to standard URL format if needed"
        return null
    }
}

// Download from modules-untouched repository
def downloadFromModulesUntouched(String version) {
    println "Version ${version} not found in releases.properties"
    println "Checking modules-untouched repository..."

    // Try to fetch memcached.properties from modules-untouched
    def untouchedProps = fetchModulesUntouchedProperties()
    def untouchedUrl = null

    if (untouchedProps) {
        untouchedUrl = untouchedProps.getProperty(version)
        if (untouchedUrl) {
            println "Found version ${version} in modules-untouched memcached.properties"
            println "Downloading from:"
            println "  ${untouchedUrl}"
        } else {
            println "Version ${version} not found in modules-untouched memcached.properties"
            println "Attempting to construct URL based on standard format..."
            // Fallback to constructed URL
            untouchedUrl = "https://github.com/Bearsampp/modules-untouched/releases/download/memcached-${version}/memcached-${version}-win64.7z"
            println "  ${untouchedUrl}"
        }
    } else {
        println "Could not fetch memcached.properties, using standard URL format..."
        // Fallback to constructed URL
        untouchedUrl = "https://github.com/Bearsampp/modules-untouched/releases/download/memcached-${version}/memcached-${version}-win64.7z"
        println "  ${untouchedUrl}"
    }

    // Determine filename from URL
    def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
    def downloadDir = file(bundleTmpDownloadPath)
    downloadDir.mkdirs()

    def downloadedFile = file("${downloadDir}/${filename}")

    // Download if not already present
    if (!downloadedFile.exists()) {
        println "  Downloading to: ${downloadedFile}"
        try {
            ant.get(src: untouchedUrl, dest: downloadedFile, verbose: true)
            println "  Download complete from modules-untouched"
        } catch (Exception e) {
            // Get available versions from releases.properties
            def availableInReleases = releasesProps.keySet().sort().join(', ')

            // Get available versions from modules-untouched if we have them
            def untouchedVersions = ""
            if (untouchedProps) {
                untouchedVersions = "\n\nVersions available in modules-untouched:\n  " +
                    untouchedProps.keySet().sort().join(', ')
            }

            throw new GradleException("""
                Failed to download version ${version}

                Tried URL: ${untouchedUrl}
                Error: ${e.message}

                This version is not available in:
                  • releases.properties
                  • modules-untouched repository

                Available versions in releases.properties:
                  ${availableInReleases}${untouchedVersions}

                Please choose an available version or add this version to releases.properties.
            """.stripIndent())
        }
    } else {
        println "  Using cached file: ${downloadedFile}"
    }

    return downloadedFile
}

// Download and extract memcached binaries
def downloadAndExtractMemcached(String version, Properties releases, String downloadPath, String extractPath) {
    def downloadUrl = releases.getProperty(version)
    def downloadedFile = null

    // Check if version exists in releases.properties
    if (!downloadUrl) {
        println "Version ${version} not found in releases.properties"
        println "Fetching from modules-untouched repository..."

        // Try to download from modules-untouched
        downloadedFile = downloadFromModulesUntouched(version)
    } else {
        println "Downloading Memcached ${version} from:"
        println "  ${downloadUrl}"

        // Determine filename from URL
        def filename = downloadUrl.substring(downloadUrl.lastIndexOf('/') + 1)
        def downloadDir = file(downloadPath)
        downloadDir.mkdirs()

        downloadedFile = file("${downloadDir}/${filename}")

        // Download if not already present
        if (!downloadedFile.exists()) {
            println "  Downloading to: ${downloadedFile}"
            ant.get(src: downloadUrl, dest: downloadedFile, verbose: true)
            println "  Download complete"
        } else {
            println "  Using cached file: ${downloadedFile}"
        }
    }

    // Extract the archive
    def extractDir = file(extractPath)
    extractDir.mkdirs()
    println "  Extracting archive..."
    def versionExtractPath = file("${extractDir}/${version}")
    if (versionExtractPath.exists()) {
        delete versionExtractPath
    }
    versionExtractPath.mkdirs()

    // Extract using 7zip
    def command = ["7z", "x", downloadedFile.absolutePath.toString(), "-o${versionExtractPath.absolutePath}".toString(), "-y"]
    def process = new ProcessBuilder(command as String[])
        .redirectErrorStream(true)
        .start()

    process.inputStream.eachLine { line ->
        if (line.trim()) println "    ${line}"
    }

    def exitCode = process.waitFor()
    if (exitCode != 0) {
        throw new GradleException("7zip extraction failed with exit code: ${exitCode}")
    }

    println "  Extraction complete"

    // Find memcached directory in extracted files
    def memcachedDir = findMemcachedDirectory(versionExtractPath)
    if (!memcachedDir) {
        throw new GradleException("Could not find memcached directory in extracted files")
    }

    println "  Found memcached directory: ${memcachedDir.name}"

    // If downloaded from modules-untouched, add a note
    if (!releases.getProperty(version)) {
        println ""
        println "NOTE: Version ${version} was downloaded from modules-untouched repository"
        println "      Consider adding it to releases.properties for future builds"
    }

    return memcachedDir
}

// Find memcached directory in extracted files
def findMemcachedDirectory(File extractPath) {
    // Look for directory containing memcached.exe
    def memcachedDirs = extractPath.listFiles()?.findAll {
        it.isDirectory() && file("${it}/memcached.exe").exists()
    }

    if (memcachedDirs && !memcachedDirs.isEmpty()) {
        return memcachedDirs[0]
    }

    // Check if memcached.exe is directly in extractPath
    if (file("${extractPath}/memcached.exe").exists()) {
        return extractPath
    }

    // Recursively search subdirectories
    def found = null
    extractPath.eachDirRecurse { dir ->
        if (!found && file("${dir}/memcached.exe").exists()) {
            found = dir
        }
    }

    return found
}

// Calculate hash for a file
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Generate hash files (MD5, SHA1, SHA256, SHA512)
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash}  ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash}  ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash}  ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash}  ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// ============================================================================
// TASKS
// ============================================================================

// Task: Main release task
tasks.register('release') {
    group = 'build'
    description = 'Build release package (use -PbundleVersion=X.X.X to specify version)'

    // Capture property at configuration time to avoid deprecation warning
    def bundleVersionProperty = project.findProperty('bundleVersion')

    doLast {
        def versionToBuild = bundleVersionProperty

        // Interactive mode if no version specified
        if (!versionToBuild) {
            def versions = getAvailableVersions()

            if (versions.isEmpty()) {
                throw new GradleException("No versions found in bin/ directory")
            }

            println ""
            println "=".multiply(70)
            println "Available ${bundleName} versions:"
            println "=".multiply(70)

            versions.eachWithIndex { version, index ->
                def location = getVersionLocation(version)
                println "  ${(index + 1).toString().padLeft(2)}. ${version.padRight(15)} ${location}"
            }
            println "=".multiply(70)
            println ""
            println "Enter version number or full version string: "
            println ""

            // Read input using Gradle's standard input
            def input = null
            try {
                def reader = new BufferedReader(new InputStreamReader(System.in))
                input = reader.readLine()
            } catch (Exception e) {
                throw new GradleException("""
                    Failed to read input. Please use non-interactive mode:
                      gradle release -PbundleVersion=X.X.X
                    """.stripIndent())
            }

            if (!input || input.trim().isEmpty()) {
                throw new GradleException("No version selected")
            }

            // Parse input - could be number or version string
            if (input.isInteger()) {
                def index = input.toInteger() - 1
                if (index < 0 || index >= versions.size()) {
                    throw new GradleException("Invalid selection: ${input}")
                }
                versionToBuild = versions[index]
            } else {
                versionToBuild = input.trim()
            }

            println ""
            println "Selected version: ${versionToBuild}"
            println ""
        }

        // Validate version configuration exists
        def configPath = getVersionPath(versionToBuild)
        if (configPath == null) {
            def availableVersions = getAvailableVersions().join(', ')
            throw new GradleException("Version configuration not found: ${versionToBuild}\n\nAvailable versions: ${availableVersions}")
        }

        println "Building release for ${bundleName} ${versionToBuild}..."
        println ""

        // Download and extract memcached binaries
        def memcachedSrcDir = downloadAndExtractMemcached(versionToBuild, releasesProps, bundleTmpDownloadPath, bundleTmpExtractPath)

        // Create prep directory
        def prepPath = file("${bundleTmpPrepPath}/${bundleName}${versionToBuild}")
        if (prepPath.exists()) {
            delete prepPath
        }
        prepPath.mkdirs()

        // Copy memcached binaries
        println "Copying memcached binaries..."
        copy {
            from memcachedSrcDir
            into prepPath
        }

        // Copy configuration files from bin directory
        println "Copying configuration files..."
        copy {
            from configPath
            into prepPath
            include 'bearsampp.conf'
        }

        // Create release directory
        def releaseDir = file("${buildBasePath}/release")
        releaseDir.mkdirs()

        // Create archive
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${bundleFormat}"
        def archivePath = file("${releaseDir}/${archiveName}")

        println "Creating archive: ${archiveName}"
        println ""

        if (bundleFormat == '7z') {
            // Use 7z command line tool - compress from within the prep directory
            def command = ["7z", "a", "-t7z", "-mx9", archivePath.absolutePath, "*"]
            def process = new ProcessBuilder(command)
                .directory(prepPath)
                .redirectErrorStream(true)
                .start()

            process.inputStream.eachLine { line ->
                if (line.trim()) println "  ${line}"
            }

            def exitCode = process.waitFor()
            if (exitCode != 0) {
                throw new GradleException("7z compression failed with exit code: ${exitCode}")
            }
        } else {
            // Use Gradle's built-in zip
            ant.zip(destfile: archivePath, basedir: prepPath)
        }

        // Generate hash files
        println "Generating hash files..."
        generateHashFiles(archivePath)

        println ""
        println "=".multiply(70)
        println "Release build completed successfully"
        println "=".multiply(70)
        println ""
        println "Package: ${archivePath}"
        println "Size: ${String.format('%.2f MB', archivePath.length() / 1024 / 1024)}"
        println ""
    }
}

// Task: Clean build artifacts
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
        }

        // Clean temporary directories
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            delete tmpDir
        }

        println "Build artifacts cleaned"
    }
}

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture properties at configuration time
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def javaVersion = JavaVersion.current()
    def gradleVersion = gradle.gradleVersion

    doLast {
        println ""
        println "=".multiply(70)
        println "Bearsampp Module Memcached - Build Info"
        println "=".multiply(70)
        println ""
        println "Project Information:"
        println "  Name:                 ${projectName}"
        println "  Version:              ${projectVersion}"
        println "  Description:          ${projectDescription}"
        println ""
        println "Bundle Properties:"
        println "  Name:                 ${bundleName}"
        println "  Release:              ${bundleRelease}"
        println "  Type:                 ${bundleType}"
        println "  Format:               ${bundleFormat}"
        println ""
        println "Paths:"
        println "  Project Directory:    ${projectBasedir}"
        println "  Build Path:           ${buildBasePath}"
        println "  Download Path:        ${bundleTmpDownloadPath}"
        println "  Extract Path:         ${bundleTmpExtractPath}"
        println ""
        println "Environment:"
        println "  Java Version:         ${javaVersion}"
        println "  Gradle Version:       ${gradleVersion}"
        println ""
        println "Version Resolution:"
        println "  1. releases.properties (local)"
        println "  2. modules-untouched memcached.properties (remote)"
        println "  3. Standard URL format (fallback)"
        println ""
        println "Quick Start:"
        println "  gradle tasks                              - List all available tasks"
        println "  gradle release                            - Interactive release build"
        println "  gradle release -PbundleVersion=1.6.39     - Non-interactive release"
        println "  gradle listVersions                       - List available versions"
        println "  gradle clean                              - Clean build artifacts"
        println ""
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println ""
        println "=".multiply(70)
        println "Build Environment Verification"
        println "=".multiply(70)
        println ""

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.gradle'] = file('build.gradle').exists()
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()
        checks['settings.gradle'] = file('settings.gradle').exists()
        checks['bin/ directory'] = file('bin').exists()

        // Check for 7z
        def sevenZipCheck = "7z".execute()
        try {
            sevenZipCheck.waitFor()
            checks['7z command'] = true
        } catch (Exception e) {
            checks['7z command'] = false
        }

        println "Environment Check Results:"
        println "-".multiply(70)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(70)
        println ""

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "All checks passed! Build environment is ready."
            println ""
            println "You can now run:"
            println "  gradle release -PbundleVersion=1.6.39     - Build specific version"
            println "  gradle listVersions                        - List available versions"
        } else {
            println "Some checks failed. Please review the requirements."
            def failedChecks = checks.findAll { !it.value }.collect { it.key }
            println ""
            println "Failed checks:"
            failedChecks.each { check ->
                println "  - ${check}"
            }
            throw new GradleException("Build environment verification failed")
        }
        println ""
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        println ""
        println "=".multiply(70)
        println "Available Memcached Releases"
        println "=".multiply(70)
        println ""

        def sortedReleases = releasesProps.sort { a, b ->
            def aParts = a.key.tokenize('.')
            def bParts = b.key.tokenize('.')
            for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
                def aNum = aParts[i].toInteger()
                def bNum = bParts[i].toInteger()
                if (aNum != bNum) return aNum <=> bNum
            }
            return aParts.size() <=> bParts.size()
        }

        sortedReleases.each { version, url ->
            println "  ${version.padRight(10)} ${url}"
        }
        println ""
        println "Total releases: ${releasesProps.size()}"
        println ""
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ and bin/archived/ directories'

    doLast {
        def versions = getAvailableVersions()

        if (versions.isEmpty()) {
            println ""
            println "No versions found in bin/ directory"
            println ""
            return
        }

        println ""
        println "Available ${bundleName} versions:"
        println "-".multiply(60)

        versions.each { version ->
            def location = getVersionLocation(version)
            println "  ${version.padRight(15)} ${location}"
        }
        println "-".multiply(60)
        println "Total versions: ${versions.size()}"
        println ""
        println "To build a specific version:"
        println "  gradle release -PbundleVersion=${versions.last()}"
        println ""
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println ""
        println "=".multiply(70)
        println "Validating build.properties"
        println "=".multiply(70)
        println ""

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "All required properties are present:"
            println ""
            required.each { prop ->
                println "  ${prop.padRight(20)} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "Missing required properties:"
            missing.each { prop ->
                println "  - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
        println ""
    }
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
